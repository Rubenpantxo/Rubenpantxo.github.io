<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jenga - Rubenpantxo.com</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            width: 100%;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 20;
        }

        .back-button:hover {
            background-color: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .score {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            z-index: 20;
        }

        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="canvas"></canvas>
        <div class="title">JENGA</div>
        <button class="back-button" onclick="window.location.href='/'">‚Üê Volver</button>
        <div class="score">Bloques extra√≠dos: <span id="score">0</span></div>
        <div class="controls">
            <p>üñ±Ô∏è Haz click en los bloques laterales para extraerlos</p>
            <p>üì± Toca los bloques en dispositivos m√≥viles</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.20.0/build/cannon.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x667eea);
        scene.fog = new THREE.Fog(0x667eea, 500, 1000);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        document.getElementById('canvas').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Physics world
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.defaultContactMaterial.friction = 0.3;

        // Jenga blocks setup
        const blocks = [];
        const bodies = [];
        const blockWidth = 1;
        const blockHeight = 0.5;
        const blockDepth = 4;
        const blockMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4a574,
            metalness: 0.2,
            roughness: 0.6,
            emissive: 0x000000
        });

        function createJengaTower() {
            const startY = blockHeight / 2;
            let blockIndex = 0;

            // Create 15 layers
            for (let layer = 0; layer < 15; layer++) {
                const yPosition = startY + layer * blockHeight;
                const rotateBlocks = layer % 2 === 0;

                // 3 blocks per layer
                for (let i = 0; i < 3; i++) {
                    const xOffset = (i - 1) * blockWidth;

                    // Create mesh
                    const geometry = new THREE.BoxGeometry(blockWidth, blockHeight, blockDepth);
                    const mesh = new THREE.Mesh(geometry, blockMaterial.clone());

                    if (rotateBlocks) {
                        mesh.rotation.z = Math.PI / 2;
                        mesh.position.set(0, yPosition, xOffset);
                    } else {
                        mesh.position.set(xOffset, yPosition, 0);
                    }

                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData.layer = layer;
                    mesh.userData.index = blockIndex;
                    mesh.userData.canRemove = layer > 2; // Can only remove from higher layers
                    scene.add(mesh);

                    // Create physics body
                    const shape = new CANNON.Box(
                        new CANNON.Vec3(blockWidth / 2, blockHeight / 2, blockDepth / 2)
                    );
                    const body = new CANNON.Body({
                        mass: 1,
                        shape: shape,
                        linearDamping: 0.3,
                        angularDamping: 0.3
                    });
                    body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);

                    if (rotateBlocks) {
                        body.quaternion.set(0, 0, Math.sin(Math.PI / 4), Math.cos(Math.PI / 4));
                    }

                    world.addBody(body);

                    blocks.push(mesh);
                    bodies.push(body);
                    blockIndex++;
                }
            }
        }

        createJengaTower();

        // Mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let score = 0;

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(blocks);

            if (intersects.length > 0) {
                const clickedBlock = intersects[0].object;

                if (clickedBlock.userData.canRemove) {
                    // Apply impulse to the block
                    const blockIndex = clickedBlock.userData.index;
                    const body = bodies[blockIndex];

                    // Calculate direction away from camera
                    const direction = clickedBlock.position.clone()
                        .sub(camera.position)
                        .normalize();

                    const impulseStrength = 50;
                    body.velocity.set(
                        direction.x * impulseStrength,
                        direction.y * impulseStrength,
                        direction.z * impulseStrength
                    );

                    // Remove from array to prevent re-selection
                    clickedBlock.userData.canRemove = false;
                    clickedBlock.material.color.set(0xff9999);
                    score++;
                    document.getElementById('score').textContent = score;

                    // Remove after 5 seconds
                    setTimeout(() => {
                        scene.remove(clickedBlock);
                        const bodyIndex = bodies.indexOf(body);
                        if (bodyIndex > -1) {
                            world.removeBody(body);
                            bodies.splice(bodyIndex, 1);
                        }
                    }, 5000);
                }
            }
        }

        window.addEventListener('click', onMouseClick);
        window.addEventListener('touchstart', (event) => {
            if (event.touches.length > 0) {
                event.clientX = event.touches[0].clientX;
                event.clientY = event.touches[0].clientY;
                onMouseClick(event);
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update physics
            world.step(1 / 60);

            // Update block positions and rotations based on physics
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                const body = bodies[i];

                if (block.parent === scene) {
                    block.position.copy(body.position);
                    block.quaternion.copy(body.quaternion);

                    // Check if block fell too low
                    if (block.position.y < -10) {
                        scene.remove(block);
                        world.removeBody(body);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // Game over check (if tower collapses)
        setInterval(() => {
            let towersStanding = 0;
            for (let i = 0; i < blocks.length; i++) {
                if (blocks[i].position.y > 0) {
                    towersStanding++;
                }
            }
            if (towersStanding === 0 && blocks.length > 0) {
                console.log('Torre derrumbada!');
            }
        }, 1000);
    </script>
</body>
</html>